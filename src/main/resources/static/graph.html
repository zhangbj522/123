<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>图-知识点总结</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
    <link rel="stylesheet" href="../static/css/typo.css">
    <link rel="stylesheet" href="../static/lib/prism/prism.css">
    <link rel="stylesheet" href="../static/lib/tocbot/tocbot.css">
    <link rel="stylesheet" href="../static/css/me.css">
    <style>
        p{
            text-indent: 2em !important;
        }
    </style>
</head>
<body>
<!--导航-->
<nav class="ui inverted attached segment m-padded-tb-mini m-shadow-small">
    <div class="ui container">
      <!--为了适应手机端查看页面，添加stackable属性，代表可堆叠，给grid之前加上stackable-->
      <div class="ui inverted secondary stackable menu">
        <h2 class="ui white header item">数据结构</h2>
          <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>线性表</a>
          <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>散列表</a>
          <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>树</a>
          <a href="#" class="active m-item item m-mobile-hide"><i class="mini file icon"></i>图</a>
          <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>算法</a>
          <div class="right m-item item m-mobile-hide">
              <!-- transparent搜索框显示为透明 inverted颜色反转 -->
              <div class="ui icon inverted transparent input">
                  <input type="text" placeholder="Search....">
                  <i class="search link icon"></i>
              </div>
          </div>
    </div>
    </div>
    <!--点击再显示，加一个图标  menu toggle只是为了使用，另一种方法也可以用id  -->
    <a href="#" class="ui menu toggle black icon button m-right-top m-mobile-show">
        <i class="sidebar icon"></i>
    </a>
</nav>

<!--中间内容-->

<div  class="m-container-small m-padded-tb-big">
  <div class="ui container">
      <div class="ui top attached segment">
          <!--头部-->
        <div class="ui  horizontal link list">
            <div class="item">
                <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1597921091300&di=110c32d1175cd47ceb8fbc8fb8cad37f&imgtype=0&src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F6657886329%2F1000" alt="" class="ui avatar image">
                <div class="content"><a href="#" class="header">张宝佳</a> </div>
            </div>
            <div class="item">
                <i class="calendar icon"></i>2020-08-07
            </div>
            <div class="item">
                <i class="eye icon"></i>23
            </div>
        </div>
      </div>

      <div class="ui attached padded segment">
          <!--内容部分-->
          <div class="ui right aligned basic segment">
            <div class="ui orange basic label">图--知识点整理</div>
          </div>
          <h2 class="ui center aligned header">图</h2>
          <br>
          <div id="content" class="typo typo-selection js-toc-content  m-padded-lr-responsive m-padded-tb-large">
            <h2 id="section2">1.图的基本概念 </h2>
              <li>图、无向图、有向图、完全图</li>
              <li>度、入度、出度</li>
              <li>路径：由顶点和相邻顶点序偶构成的边所形成的序列</li>
              <li>连通图、连通分量（无向图）</li>
              <li>强连通图、连通分量：极大强连通子图（有向图）</li>
            <h2 id="section3">2.图的存储结构 </h2>
              <li>包括邻接矩阵、邻接表、逆邻接表</li>
              <li>邻接矩阵：不带权图（用0、1表示），带权图（用权重、无穷表示）；邻接矩阵第i行之和可求出顶点Vi的度</li>
              <li>邻接表：包含顶点表和边表，邻接表不唯一（意味着边表顺序可以不一致）</li>
              <li>逆邻接表</li>
            <h2 id="section4">3.图的遍历 BFS、DFS </h2>
              <li>BFS（广度优先遍历）</li>
              <li>DFS（深度优先遍历）：只有当访问完当前结点所连接的全部结点之后才能回溯到上一层</li>
            <h2 id="section5">4.图的应用 </h2>
            <h2 id="section6">4.1 最小生成树 Prim、Kruskal </h2>
              <p>生成树：一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边。</p>
              <p>最小（代价）生成树：Minimum (cost) spanning tree。构造连通网的最小代价生成树称为最小生成树。（一棵生成树的代价就是树上各边的代价之和）</p>
              <li>构造最小生成树的2种算法：Prim算法、Kruskal算法 </li>
                   <li>Prim算法</li>
                   <li>思想：从图中任意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连顶点并入当前树中，此时得到了一棵有两个顶点的树。然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树。以此类推，直到图中所有顶点都被并入树中为之，此时得到的生成树就是最小生成树。</li>
                   <li>假设全部顶点的集合是V，已经被挑选出来的是U，那么从集合V-U中不断挑选权值最低的点。（这里的权值最低，是相对于U中所有的点来说，是把U看成一个整体。Prim算法和后面的求最短路径的Dijkstra算法有些相似，具体区别看Prim算法和Dijkstra算法的比较）。
                       以某起点为顶点，逐步找各顶点上最小权值的边来构建最小生成树。（这就像是我们如果去参观某个展会，例如世博会，你从一个入口进去，然后找你所在位置周边的场馆中你最感兴趣的场馆观看，看完后再用同样的办法看下一个）</li>
                   <li>时间复杂度</li>
                   <li>举例：下图所示的带权无向图采用prim算法求解最小生成树的过程如下所示：
                       1）从顶点0开始，此时候选边为5、1、2，从中选择最小边长为1的边，加入到当前树中。
                       2）此时已有的边：(0,2)，此时已有顶点：0、2
                       此时候选边为5、3、2、6、2，最小边长为2，选择其加入（有2条，随便选1条符合条件即可）
                       3）此时已有的边：(0,2),(0,3)，此时已有顶点：0、2、3
                       此时候选边为5、3、2、3，最小边长为2，选择其加入
                       4）此时已有的边：(0,2),(0,3),(2,4)，此时已有顶点：0、2、3、4
                       此时侯选边为5、3、4，最小边长为3，选择其加入
                       5）此时已有的边：(0,2),(0,3),(2,4),(2,1)，此时已有顶点：0、1、2、3、4
                       已包含全部顶点，生成树求解过程完毕。
                       <img src="../static/images/graph01.png" alt="" class="ui fluid rounded image"></li>
                   <li>Kruskal算法</li>
                      <li>思想：选择最短边加入，并且确保不成环路。每次找出候选边中权值最小的边，就将该边并入树中（不能有环），重复此过程直到所有边都被检测完为止。</li>
                      <li>把所有的边排序，依次从小到大排列，按顺序选择边加入集合，如果选择该边构成了回路，则舍弃这条边。直到所有顶点都在同一集合中。</li>
                      <li>时间复杂度</li>
              <p>两个算法对比：</p>
              <p>Prim算法：针对顶点，对于稠密图(边数非常多的情况)更好；</p>
              <p>Kruskal算法：针对边，对于稀疏图(边数少)时更好。</p>
            <h2 id="section7">4.2 最短路径 Dijkstra、Floyd </h2>
              <li>基本概念：最短路径是指两顶点之间经过的边上权值之和最少的路径。</li>
              <li>求最短路径的算法：Dijstra算法（从某个源点到其余各顶点的最短路径）、Floyd算法（每一对顶点之间的最短路径）</li>
              <li>Dijstra算法</li>
                   <li>思想：从图中选取到源点v0路径长度最短的顶点并入到集合S中，修改顶点v0到剩下的顶点的最短路径长度值，直到所有顶点都并入到S中为止。</li>
                   <li>例题
                       <img src="../static/images/graph02.png" alt="" class="ui fluid rounded image"></li>
              <li>Folyd算法 </li>
              <p>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，从任意节点i到任意节点j的最短路径，不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) < Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
            <h2 id="section8">4.3 AOV网 拓扑排序 </h2>
              <li>AOV网：重点是顶点。顶点表示活动，边表示活动之间的先后关系。</li>
              <li>拓扑排序：</li>
                      <li>基本概念：拓扑排序是对有向无环图G的排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若存在u到v的路径，则在拓扑排序序列中一定是u出现在v的前边。（与边无关）</li>
                      <li>实现思路：
                          从有向无环图中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。</li>
                      <li>时间复杂度：
                          <img src="../static/images/graph03.png" alt="" class="ui fluid rounded image"></li>
                      <li>具体实现：
                          拓扑排序的过程中，需要删除顶点，显然用邻接表会更加方便。
                          考虑到算法过程中时钟要查找入度为0的顶点，因此我们设置一个indegree数组，用来存放各顶点的入度数目。
                          判断拓扑序列是否存在：看是否为无环图</li>
            <h2 id="section1">4.4 AOE网 关键路径 </h2>
              <li>AOE网：重点是边。边表示活动，顶点表示事件（事件是新活动开始或旧活动结束的标志）</li>
              <li>关键路径：在AOE（边表示活动）网中，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径。把关键路径上的活动称为关键活动。关键路径既是最短，又是最长。最短：完成工期的最短事件。最长：图中的最长路径。</li>
              <li>求关键路径的过程：</li>
                                <li>Step1.对事件（顶点）进行拓扑排序：（比较复杂繁琐的一步）
                                    Step1.1求事件的最早发生时间（从前往后计算）（上一个事件+权值）的最大值（多对1，求最大值）
                                    Step1.2求事件的最晚发生时间（从后往前计算）（下一个事件-权值）的最小值（1对多，求最小值）</li>
                                <li>Step2:写出活动（边）：（该步骤完全根据Step1中的写，不复杂）
                                    Step2.1：求活动的最早发生时间（即上一个事件的最早开始时间）
                                    Step2.2：求活动的最晚发生时间（即下一个事件的最晚开始时间-边的权值）</li>
                                <li>求最早：从前往后计算
                                    求最晚：从后往前计算</li>







      <div class="ui attached positive message ">
          <!--博客信息说明-->

      </div>
      <div id="comment-container" class="ui bottom attached segment">
          <!--留言区域列表-->
          <div class="ui teal segment">
            <div class="ui comments">
              <h3 class="ui dividing header"><trans oldtip="Comments" newtip="评论意见">Comments</trans></h3>
                <div class="comment">
                  <a class="avatar">
                  <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1597935955534&di=3fa7d12be75004dc4beec42dcc5e4664&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F0df3d7ca7bcb0a46fe2a8a206863f6246b60af9a.jpg">
                  </a>
               <div class="content">
               <a class="author"><trans oldtip="James" newtip="詹姆斯">James</trans></a>
              <div class="metadata">
                <span class="date"><trans oldtip="Today at 5:22PM" newtip="今天下午5:22">Today at 5:22PM</trans></span>
              </div>
              <div class="text"><trans oldtip=" How interesting! " newtip="多么有趣啊！"> How interesting! </trans></div>
              <div class="actions">
              <a class="reply">回复</a>
            </div>
           </div>
               </div>
           <div class="comment">
            <a class="avatar">
              <img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1894767775,3046783065&fm=26&gp=0.jpg">
            </a>
           <div class="content">
             <a class="author"><trans oldtip="Kobe Bryant" newtip="科比·布莱恩特">Kobe Bryant</trans></a>
             <div class="metadata">
               <span class="date"><trans oldtip="Yesterday at 8:24AM" newtip="昨天中午8:24">Yesterday at 8:24AM</trans></span>
             </div>
      <div class="text">
        <p><trans oldtip="This has been very useful for my research. Thanks as well!" newtip="这对我的研究非常有用。也谢谢你！">This has been very useful for my research. Thanks as well!</trans></p>
      </div>
      <div class="actions">
        <a class="reply">回复</a>
      </div>
    </div>
    <div class="comments">
      <div class="comment">
        <a class="avatar">
          <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1597936329639&di=e0f33ffb975aa967b0e5c21f25c151a5&imgtype=0&src=http%3A%2F%2Fa.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F9358d109b3de9c82713ecb576c81800a18d8438a.jpg">
        </a>
        <div class="content">
          <a class="author"><trans oldtip="Michael Jordan" newtip="迈克尔·乔丹">Michael Jordan</trans></a>
          <div class="metadata">
            <span class="date"><trans oldtip="Just now" newtip="刚才">Just now</trans></span>
          </div>
          <div class="text"><trans oldtip=" Kobe ，I agree with you :) " newtip="科比，我同意你的说法：)"> Kobe ，I agree with you :) </trans></div>
          <div class="actions">
            <a class="reply">回复</a>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="comment">
    <a class="avatar">
      <img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1194695653,3166432041&fm=26&gp=0.jpg">
    </a>
    <div class="content">
      <a class="author"><trans oldtip="Chris·Paul" newtip="克里斯·保罗">Chris·Paul</trans></a>
      <div class="metadata">
        <span class="date"><trans oldtip="3 days ago" newtip="3天前">3 days ago</trans></span>
      </div>
      <div class="text"><trans oldtip=" Jesus, this is amazing. Thanks so much " newtip="天呐，这太棒了。非常感谢"> Jesus, this is amazing. Thanks so much.  </trans></div>
      <div class="actions">
        <a class="reply">回复</a>
      </div>
    </div>
  </div>

</div>
          </div>
          <div class="ui form">
            <div class="filed">
                <textarea name="content" placeholder="请输入评论信息..."></textarea>
            </div>
            <div class="fields">
              <div class="field m-mobile-wide m-margin-bottom-small">
                 <div class="ui left icon input">
                     <i class="user icon"></i>
                   <input type="text" name="nickname" placeholder="姓名">
                 </div>
              </div>
              <div class="field m-mobile-wide m-margin-bottom-small">
                 <div class="ui left icon input">
                     <i class="mail icon"></i>
                   <input type="text" name="email" placeholder="邮箱">
                 </div>
              </div>
              <div class="field m-mobile-wide m-margin-bottom-small">
                 <button class="ui teal button m-mobile-wide m-margin-bottom-small"><i class="edit icon"></i> 发布</button>
              </div>
            </div>
          </div>
      </div>
  </div>
</div>
<div   class="m-padded m-fixed m-right-bottom "  >
  <div class="ui vertical icon buttons ">
     <button type="button" class="ui toc teal button">目录</button>
     <a href="#comment-container" class="ui teal button">留言</a>
     <button type="button" class="ui wechat icon button"><i class="weixin icon"></i> </button>


     <a href="#" class="ui icon button"><i class="chevron up icon"></i></a>
     <!--直接返回顶部修改为平滑滚动到顶部-->
      <!--<div id="toTop-button" class="ui icon button"><i class="chevron up icon"></i> </div>-->
  </div>
   <!--生成二维码  将已经写死的二维码注释掉，既可以随机生成二维码-->
    <div id="qrcode" class="ui wechat-qr flowing popup transition hidden " style="width: 130px !important;">
        <!--
          <div id="qrcode" class="ui wechat-qr flowing popup transition hidden m-padded-mini" style="width: 130px !important;">
          <img src="images/wechat.jpg" alt="" class="ui rounded image "  style="width:120px !important;">
        -->
    </div>
</div>
<!--生成目录-->
<div class="ui toc-container flowing popup  transition hidden" style="width:250px !important;">
  <ol class="js-toc">

  </ol>
</div>



<script src="https://cdn.jsdelivr.net/npm/jquery@3.2/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
<!--<script src="//cdn.jsdelivr.net/npm/jquery.scrollto@2.1.2/jquery.scrollTo.min.js"></script>-->

<script src="..//static/lib/prism/prism.js"></script>
<script src="..//static/lib/tocbot/tocbot.min.js"></script>
<script src="..//static/lib/qrcode/qrcode.min.js"></script>

<script>


    //item使用其来引用到m-mobile-hidden  用以判断显示display
    $('.menu.toggle').click(function () {
       $('.m-item').toggleClass('m-mobile-hide');
    });
    //通过CSS定位到相应区域
    $('#payButton').popup({
        popup: $('.payQR.popup'),
        on:'click',
        position:'bottom center',
    });
    //初始化
    tocbot.init({
  // Where to render the table of contents.显示目录的区域
  tocSelector: '.js-toc',
  // Where to grab the headings to build the table of contents.生成目录的源，内容
  contentSelector: '.js-toc-content',
  // Which headings to grab inside of the contentSelector element. 生成目录的级别
  headingSelector: 'h1, h2, h3',
    });
    //鼠标移入微信图标后出现二维码
    $('.wechat').popup({
        popup: $('.wechat-qr.popup'),
        position:'left center',
    });
    $('.toc.button').popup({
        popup: $('.toc-container.popup'),
        on:'click',
        position:'left center',
    });
    //生成二维码的js代码  test 为二维码承载元素的id
    var qrcode = new QRCode("qrcode", {
    text: "http://jindo.dev.naver.com/collie",
    width: 110,
    height: 110,
    colorDark : "#000000",
    colorLight : "#ffffff",
    correctLevel : QRCode.CorrectLevel.H
  });
  //平滑滚动插件  失败
  /*$('#toTop-button').click(function(){
        $(window).scrollTo(0,500);
  });*/

</script>
</body>
</html>