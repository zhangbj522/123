<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>散列表详情</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
    <link rel="stylesheet" href="../static/css/typo.css">
    <link rel="stylesheet" href="../static/lib/prism/prism.css">
    <link rel="stylesheet" href="../static/lib/tocbot/tocbot.css">
    <link rel="stylesheet" href="../static/css/me.css">
    <style>
        p{
            text-indent: 2em !important;
        }

    </style>
</head>
<body>
<!--导航-->
<nav class="ui inverted attached segment m-padded-tb-mini m-shadow-small">
    <div class="ui container">
      <!--为了适应手机端查看页面，添加stackable属性，代表可堆叠，给grid之前加上stackable-->
      <div class="ui inverted secondary stackable menu">
        <h2 class="ui teal header item">数据结构</h2>
          <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>线性表</a>
          <a href="#" class="active m-item item m-mobile-hide"><i class="mini file icon"></i>散列表</a>
          <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>树</a>
          <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>图</a>
          <a href="#" class="m-item item m-mobile-hide"><i class="mini file icon"></i>算法</a>
          <div class="right m-item item m-mobile-hide">
              <!-- transparent搜索框显示为透明 inverted颜色反转 -->
              <div class="ui icon inverted transparent input">
                  <input type="text" placeholder="Search....">
                  <i class="search link icon"></i>
              </div>
          </div>
    </div>
    </div>
    <!--点击再显示，加一个图标  menu toggle只是为了使用，另一种方法也可以用id  -->
    <a href="#" class="ui menu toggle black icon button m-right-top m-mobile-show">
        <i class="sidebar icon"></i>
    </a>
</nav>

<!--中间内容-->

<div  class="m-container-small m-padded-tb-big">
  <div class="ui container">
      <div class="ui top attached segment">
          <!--头部-->
        <div class="ui  horizontal link list">
            <div class="item">
                <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1597921091300&di=110c32d1175cd47ceb8fbc8fb8cad37f&imgtype=0&src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F6657886329%2F1000" alt="" class="ui avatar image">
                <div class="content"><a href="#" class="header">张宝佳</a> </div>
            </div>
            <div class="item">
                <i class="calendar icon"></i>2020-08-07
            </div>
            <div class="item">
                <i class="eye icon"></i>23
            </div>
        </div>
      </div>
      <div class="ui  attached segment">
          <!--图片区域-->
          <img src="../static/images/hash1.png" alt="" class="ui fluid rounded image">
      </div>
      <div class="ui attached padded segment">
          <!--内容部分-->
          <div class="ui right aligned basic segment">
            <div class="ui orange basic label">哈希表--知识点整理</div>
          </div>
          <h2 class="ui center aligned header">散列表</h2>
          <br>
          <div id="content" class="typo typo-selection js-toc-content  m-padded-lr-responsive m-padded-tb-large">
            <h2 id="section1">一、哈希表概念 </h2>
            <p><b>哈希表</b> （Hash table，也叫散列表），是根据关键码值（Key-value）而直接访问在内存存储位置的数据结构。也就是说，它通过把键值通过一个函数的计算，映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。</p>
            <h4>1.散列表目的与特征</h4>
              <p>数组的最大特点就是：寻址容易，插入和删除困难；
                 而链表的特点正好相反，寻址困难，而插入和删除操作容易。
                  哈希表就是这样一个集查找、插入和删除操作于一身的数据结构。</p>
              <p>哈希表和哈希函数的标准定义：若关键字为key，则其值value存放在f(key)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为哈希函数，按这个思想建立的表为哈希表。</p>
            <h4>2.散列表的原理</h4>
              <p>哈希表的特点是由键值对组合key-value（键和值）组成的，key-关键字 value-真实的数据，f（key）存储值value所在的地址，。 每一个key都有一个对应value，value可以重复，key不可重复。
              </p>
              <p>HashMap的数据结构为数组+链表，以key，value的形式存值，通过调用put与get方法来存值与取值。它内部维护了一个Entry数组，得到key的hashCode值将其移位按位与运算,然后再通过跟数组的长度-1作逻辑与运算得到一个index值来确定数据存储在Entry数组当中的位置，通过链表来解决hash冲突问题。当发生碰撞了，对象将会储存在链表的下一个节点中。</p>

              <p>哈希算法是通过put(key,value)（添加）和get(key)的方法（返回索引）来实现存储和获取对象。当需要put值的时候，先调用hash算法，将key解析成固定长度的数字索引（hashCode的值），此索引值就是value值存储的位置；当需要获取value 时，将key用同样的算法解析hashCode成同样的数字索引，然后获取对应的value。
              </p>
            <h4>3.哈希表的应用</h4>
              <ul>
                  <li>查找、模拟映射关系；</li>
                  <li>防止重复</li>
                  <li>数据缓存</li>
              </ul>
             <h2 id="section2">二、哈希表的实现方法</h2>
              <p>哈希表的实现就是映射函数构造，看某个元素具体属于哪一个类别。如何构造我们要考虑两个问题：</p>
              <ul>
                  <li>n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的地址空间尽量小。</li>
                  <li>无论用什么方法存储，目的都是尽量均匀地存放元素，以避免冲突。</li>
              </ul>
              <p>哈希表的映射函数构造方法也有很多，常见的有：直接定址法、 除留余数法、 乘余取整法、 数字分析法、 平方取中法、 折叠法、 随机数法等。</p>
            <h4>1.直接定位法</h4>
              <p>Hash(key) = a·key + b (a、b为常数)</p>
               <p>优点：以关键码key的某个线性函数值为哈希地址，不会产生冲突.</p>
               <p>缺点：要占用连续地址空间，空间效率低。</p>
               <p>例：关键码集合为{100，300，500，700，800，900}， 选取哈希函数为Hash(key)=key/100， 则存储结构（哈希表）如下：</p>
              <img alt="" src="../static/images/hash2.png" style="width: 420px; height: 186px;" />
              </p>
            <h4>2.除留余数法</h4>
              <p>Hash(key) = key mod p (p是一个整数)</p>
               <p>特点：以关键码除以p的余数作为哈希地址。</p>
            <h4>3.乘余取整法</h4>
              <p>Hash(key) = [B*( A*key mod 1 ) ]下取整  (A、B均为常数，且0<A<1，B为整数)<br/>
               特点：以关键码key乘以A，取其小数部分，然后再放大B倍并取整，作为哈希地址。<br/>

              </p>
            <h4>4.数字分析法</h4>
              <p>
               特点：某关键字的某几位组合成哈希地址。所选的位应当是：各种符号在该位上出现的频率大致相同。<br/>
               例：有一组（例如80个）关键码，其样式如下：
              </p>
              <img alt="" src="../static/images/hash3.png" style="width: 500px; height: 186px;" />
            <h4>5.平方取中法</h4>
              <p>
               特点：对关键码平方后，按哈希表大小，取中间的若干位作为哈希地址。</p>
               <p>理由：因为中间几位与数据的每一位都相关。</p>
               例：2589的平方值为6702921，可以取中间的029为地址。
            <h4>6.折叠法</h4>
              <p>
               特点：将关键码自左到右分成位数相等的几部分（最后一部分位数可以短些），然后将这几部分叠加求和，并按哈希表表长，取后几位作为哈希地址。<br/>
               适用于：每一位上各符号出现概率大致相同的情况。</p>
               <p>法1:移位法 ── 将各部分的最后一位对齐相加。</p>
              <p> 法2:间界叠加法──从一端向另一端沿分割界来回折叠后，最后一位对齐相加。</p>
               例：元素42751896, 用法1： 427＋518＋96=1041      用法2： 427 518 96—> 724+518+69 =1311

<h2 id="section3">三、哈希表定址与解决冲突：</h2>
    <h4>1.开放定址法</h4>
     <p>如果两个数据元素的哈希值相同，则在哈希表中为后插入的数据元素另外选择一个表项。当程序查找哈希表时，如果没有在第一个对应的哈希表项中找到符合查找要求的数据元素，程序就会继续往后查找，直到找到一个符合查找要求的数据元素，或者遇到一个空的表项。线性探测带来的最大问题就是冲突的堆积，你把别人预定的坑占了，别人也就要像你一样去找坑。改进的办法有二次方探测法和随机数探测法。开放地址法包括线性探测、二次探测以及双重散列等方法。
     </p>
     <p>设计思路：有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。</p>
     <h6>具体实现：</h6>
      1）线性探测法<br/>
      <p>Hi=(Hash(key)+di) mod m  ( 1≤i < m )    其中： Hash(key)为哈希函数  m为哈希表长度  di 为增量序列 1，2，…m-1，且di=i</p>

     <p>例：关键码集为 {47，7，29，11，16，92，22，8，3}，</p>
     <p>设：哈希表表长为m=11； 哈希函数为Hash(key)=key mod 11； 拟用线性探测法处理冲突。建哈希表如下：</p>
      <img alt="" src="../static/images/hash4.png" style="width: 500px; height: 186px;" /><br/>
      <p>解释：</p>
       <ul>
           <li>47、7（以及11、16、92）均是由哈希函数得到的没有冲突的哈希地址；</li>
           <li>Hash(29)=7，哈希地址有冲突，需寻找下一个空的哈希地址：由H1=(Hash(29)+1) mod 11=8，哈希地址8为空，因此将29存入。</li>
           <li>另外，22、8、3同样在哈希地址上有冲突，也是由H1找到空的哈希地址的。其中3 还连续移动了两次（二次聚集）</li>
       </ul>
    <pre class="language-css"><code class="language-css">
    int FindHash(SeqList* pL, KeyType K)
{
    int c=0;  int p=Hash(K); /*求得哈希地址*/
    while(pL->data[p].key!=NULL_KEY && K!=pL->data[p].key && ++c<MAXNUM)    p=Hash(K+c);
    if(K==pL->data[p].key) {
        printf("\n成功找到 %d", K);
        return p; /*查找成功,p返回待查数据元素下标*/
    }
    else if(pL->data[p].key==NULL_KEY) {
       printf("\n无法找到 %d , 在位置 %d 插入。", K,p);
       pL->data[p].key = K;   pL->n++;
       return p;
    } else {
       printf("\n无法找到 %d , 表已满。", K);
       return -1;
    }
  }
</code></pre>
   2）二次探测法<br/>
    <p> 仍举上例，改用二次探测法处理冲突，建表如下：</p>
       <img alt="" src="../static/images/hash5.png" style="width: 500px; height: 186px;" /><br/>
     <br/>
     <p>Hi=(Hash(key)±di) mod m   其中：Hash(key)为哈希函数 m为哈希表长度，m要求是某个4k+3的质数； di为增量序列 12，-12，22-22，…，q2</p>
     <p>注：只有3这个关键码的冲突处理与上例不同， Hash(3)=3，哈希地址上冲突，由 H1=(Hash(3)+12) mod 11=4，仍然冲突； H2=(Hash(3)-12) mod 11=2，找到空的哈希地址，存入。</p>
    <h4>2.链地址法</h4>
     <p>
      基本思想：基本思想：将具有相同哈希地址的记录链成一个单链表，m个哈希地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。</p>
      <p>注：有冲突的元素可以插在表尾,也可以插在表头</p>
      <p>例：设{ 47, 7, 29, 11, 16, 92, 22, 8, 3, 50, 37, 89 }的哈希函数为： Hash(key)=key mod 11， 用拉链法处理冲突，则建表如下图所示。</p>
      <img alt="" src="../static/images/hash6.png" style="width: 500px; height: 300px;" /><br/>
     <h4>3.双哈希表函数法</h4>
      <p>
          Hi=RHi(key)     i=1, 2, …，k</p>>
       <p>  RHi均是不同的哈希函数，当产生冲突时就计算另一个哈希函数，直到冲突不再发生。</p>
        <p>  优点：不易产生聚集；</p>
        <p>  缺点：增加了计算时间。</p>
<h2 id="section4">四、哈希表的查找和分析</h2>
  <h4>1.哈希查找过程</h4>
    <p>哈希表的主要目的是用于快速查找，且插入和删除操作都要用到查找。由于散列表的特殊组织形式，其查找有特殊的方法。 设散列为HT[0…m-1]，散列函数为H(key)，解决冲突的方法为R(x, i) ，则在散列表上查找定值为K的记录的过程如图所示。</p>
  <div style="text-align: center;">
           <img alt="" src="../static/images/hash7.png" style="width: 500px; height: 400px;" /><br />
  </div>
  <h4>2.查找效率分析</h4>
  <p><b>明确</b> 散列函数没有“万能”通式，要根据元素集合的特性而分别构造。</p>
  <p>由于冲突的产生，使得哈希表的查找过程仍然要进行比较，仍然要以平均查找长度ASL来衡量。 一般地，ASL依赖于哈希表的装填因子α，它标志着哈希表的装满程度。</p>
  <div style="text-align: center;">
           <img alt="" src="../static/images/hash8.png" style="width: 420px; height: 186px;" /><br />
  </div>
          </div>
<!--          &lt;!&ndash;定义标签&ndash;&gt;-->
<!--          <div class="m-padded-lr-responsive m-padded-tb-large">-->
<!--              <div class="ui basic teal left pointing label">哈希表</div>-->
<!--          </div>-->


      </div>
      <div class="ui attached positive message ">
          <!--博客信息说明-->
          <div class="ui middle aligned grid">
              <div class="eleven wide column">
                <ui class=" list">
                    <li>作者：张宝佳（联系作者）</li>
                    <li>发表时间：2020-08-15</li>
                    <li>版权声明：自由转载-非商用-非衍生-保持署名</li>
                    <li>公众号转载：请在文末添加作者公众二维码</li>
                </ui>
              </div>
              <div class="five wide column">
                <img src="../static/images/wechat.jpg" alt="" class="ui right floated rounded bordered image" style="width: 110px">
              </div>
          </div>
      </div>
      <div id="comment-container" class="ui bottom attached segment">
          <!--留言区域列表-->
          <div class="ui teal segment">
              <div class="ui comments">
                  <h3 class="ui dividing header"><trans oldtip="Comments" newtip="评论意见">Comments</trans></h3>
                  <div class="comment">
                      <a class="avatar">
                          <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1597935955534&di=3fa7d12be75004dc4beec42dcc5e4664&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F0df3d7ca7bcb0a46fe2a8a206863f6246b60af9a.jpg">
                      </a>
                      <div class="content">
                          <a class="author"><trans oldtip="James" newtip="詹姆斯">James</trans></a>
                          <div class="metadata">
                              <span class="date"><trans oldtip="Today at 5:22PM" newtip="今天下午5：22">Today at 5:22PM</trans></span>
                          </div>
                          <div class="text"><trans oldtip=" How interesting! " newtip="多么有趣啊！"> How interesting! </trans></div>
                          <div class="actions">
                              <a class="reply">回复</a>
                          </div>
                      </div>
                  </div>
                  <div class="comment">
                      <a class="avatar">
                          <img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1894767775,3046783065&fm=26&gp=0.jpg">
                      </a>
                      <div class="content">
                          <a class="author"><trans oldtip="Kobe Bryant" newtip="科比·布莱恩特">Kobe Bryant</trans></a>
                          <div class="metadata">
                              <span class="date"><trans oldtip="Yesterday at 8:24AM" newtip="昨天早上8：24">Yesterday at 8:24AM</trans></span>
                          </div>
                          <div class="text">
        <p><trans oldtip="This has been very useful for my research. Thanks as well!" newtip="这对我的研究非常有用。也谢谢你！">This has been very useful for my research. Thanks as well!</trans></p>
      </div>
      <div class="actions">
        <a class="reply">回复</a>
      </div>
    </div>
    <div class="comments">
      <div class="comment">
        <a class="avatar">
          <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1597936329639&di=e0f33ffb975aa967b0e5c21f25c151a5&imgtype=0&src=http%3A%2F%2Fa.hiphotos.baidu.com%2Fzhidao%2Fpic%2Fitem%2F9358d109b3de9c82713ecb576c81800a18d8438a.jpg">
        </a>
        <div class="content">
          <a class="author"><trans oldtip="Michael Jordan" newtip="迈克尔·乔丹">Michael Jordan</trans></a>
          <div class="metadata">
            <span class="date"><trans oldtip="Just now" newtip="刚才">Just now</trans></span>
          </div>
          <div class="text"><trans oldtip=" Kobe ，I agree with you :) " newtip="科比，我同意你的说法：)"> Kobe ，I agree with you :) </trans></div>
          <div class="actions">
            <a class="reply">回复</a>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="comment">
    <a class="avatar">
      <img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1194695653,3166432041&fm=26&gp=0.jpg">
    </a>
    <div class="content">
      <a class="author"><trans oldtip="Chris·Paul" newtip="克里斯·保罗">Chris·Paul</trans></a>
      <div class="metadata">
        <span class="date"><trans oldtip="3 days ago" newtip="3天前">3 days ago</trans></span>
      </div>
      <div class="text"><trans oldtip=" Jesus, this is amazing. Thanks so much " newtip="天呐，这太棒了。非常感谢"> Jesus, this is amazing. Thanks so much </trans></div>
      <div class="actions">
        <a class="reply">回复</a>
      </div>
    </div>
  </div>

</div>
          </div>
          <div class="ui form">
            <div class="filed">
                <textarea name="content" placeholder="请输入评论信息..."></textarea>
            </div>
            <div class="fields">
              <div class="field m-mobile-wide m-margin-bottom-small">
                 <div class="ui left icon input">
                     <i class="user icon"></i>
                   <input type="text" name="nickname" placeholder="姓名">
                 </div>
              </div>
              <div class="field m-mobile-wide m-margin-bottom-small">
                 <div class="ui left icon input">
                     <i class="mail icon"></i>
                   <input type="text" name="email" placeholder="邮箱">
                 </div>
              </div>
              <div class="field m-mobile-wide m-margin-bottom-small">
                 <button class="ui teal button m-mobile-wide m-margin-bottom-small"><i class="edit icon"></i> 发布</button>
              </div>
            </div>
          </div>
      </div>
  </div>
</div>
<div   class="m-padded m-fixed m-right-bottom "  >
  <div class="ui vertical icon buttons ">
     <button type="button" class="ui toc teal button">目录</button>
     <a href="#comment-container" class="ui teal button">留言</a>
     <button type="button" class="ui wechat icon button"><i class="weixin icon"></i> </button>


     <a href="#" class="ui icon button"><i class="chevron up icon"></i></a>
     <!--直接返回顶部修改为平滑滚动到顶部-->
      <!--<div id="toTop-button" class="ui icon button"><i class="chevron up icon"></i> </div>-->
  </div>
   <!--生成二维码  将已经写死的二维码注释掉，既可以随机生成二维码-->
    <div id="qrcode" class="ui wechat-qr flowing popup transition hidden " style="width: 130px !important;">
        <!--
          <div id="qrcode" class="ui wechat-qr flowing popup transition hidden m-padded-mini" style="width: 130px !important;">
          <img src="images/wechat.jpg" alt="" class="ui rounded image "  style="width:120px !important;">
        -->
    </div>
</div>
<!--生成目录-->
<div class="ui toc-container flowing popup  transition hidden" style="width:250px !important;">
  <ol class="js-toc">

  </ol>
</div>


<!--底部-->
<footer class="ui inverted vertical segment m-padded-tb-massive">
    <div class="ui  center aligned container">
        <div class="ui inverted divided stackable grid">
          <!--grid分成16份，9份做三个盒子，剩下7份为一个盒子-->
            <div  class="three wide column ">
                <div class="ui inverted  link list">
                    <div class="item">
                        <img src="../static/images/wechat.jpg" class="ui rounded image " alt="" width="100px" height="100px""/>
                    </div>
                </div>
            </div>
            <div class="three wide column">
                <h4 class="ui inverted header m-text-thin m-text-space ">最新博客</h4>
                <div class="ui inverted  link list">
                    <a href="#" class="item">生活的价值</a>
                    <a href="#" class="item">学习的动力</a>
                    <a href="#" class="item">向上的勇气</a>
                </div>
            </div>
            <div class="three wide column">
                <h4 class="ui inverted header m-text-thin m-text-space ">联系我</h4>
                <div class="ui inverted  link list">
                    <a href="#" class="item">Email:18192062162@163.com</a>
                    <a href="#" class="item">QQ:2632995044</a>
                </div>
            </div>
            <div class="seven wide column">
                <h4 class="ui inverted header m-text-thin m-text-space">Blog</h4>
                <p class="m-text-thin m-text-space m-opacity-mini">这是我的个人博客，会分享关于编程、写作、思考相关的内容，希望可以给大家提供帮助。</p>
            </div>
        </div>
        <div class="ui inverted section divider"></div>
        <p class="m-text-thin m-text-space m-opacity-tiny">©2020 本博客仅用于个人学习使用，不得用于其他商业用途，违反者必将追究法律责任。</p>
    </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.2/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
<!--<script src="//cdn.jsdelivr.net/npm/jquery.scrollto@2.1.2/jquery.scrollTo.min.js"></script>-->

<script src="..//static/lib/prism/prism.js"></script>
<script src="..//static/lib/tocbot/tocbot.min.js"></script>
<script src="..//static/lib/qrcode/qrcode.min.js"></script>

<script>


    //item使用其来引用到m-mobile-hidden  用以判断显示display
    $('.menu.toggle').click(function () {
       $('.m-item').toggleClass('m-mobile-hide');
    });
    //通过CSS定位到相应区域
    $('#payButton').popup({
        popup: $('.payQR.popup'),
        on:'click',
        position:'bottom center',
    });
    //初始化
    tocbot.init({
  // Where to render the table of contents.显示目录的区域
  tocSelector: '.js-toc',
  // Where to grab the headings to build the table of contents.生成目录的源，内容
  contentSelector: '.js-toc-content',
  // Which headings to grab inside of the contentSelector element. 生成目录的级别
  headingSelector: 'h1, h2, h3',
    });
    //鼠标移入微信图标后出现二维码
    $('.wechat').popup({
        popup: $('.wechat-qr.popup'),
        position:'left center',
    });
    $('.toc.button').popup({
        popup: $('.toc-container.popup'),
        on:'click',
        position:'left center',
    });
    //生成二维码的js代码  test 为二维码承载元素的id
    var qrcode = new QRCode("qrcode", {
    text: "http://jindo.dev.naver.com/collie",
    width: 110,
    height: 110,
    colorDark : "#000000",
    colorLight : "#ffffff",
    correctLevel : QRCode.CorrectLevel.H
  });
  //平滑滚动插件  失败
  /*$('#toTop-button').click(function(){
        $(window).scrollTo(0,500);
  });*/

</script>
</body>
</html>